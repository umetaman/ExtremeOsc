using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Text;

namespace ExtremeOsc.SourceGenerator
{
    using static OscSyntax;
    using static PackableEmitter;

    [Generator(LanguageNames.CSharp)]
    internal partial class OscCallbackSourceGenerator : IIncrementalGenerator
    {
        public const string OscReceiverAttributeName = "ExtremeOsc.Annotations.OscReceiverAttribute";
        public const string OscCallbackAttributeName = "ExtremeOsc.Annotations.OscCallbackAttribute";
        public const string IOscReceivableName = "ExtremeOsc.IOscReceivable";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var receiverTypes = context.GetSourceWithAttribute(OscReceiverAttributeName);
            context.RegisterSourceOutput(receiverTypes, EmitReceiver);
        }

        private static void EmitReceiver(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
        {
            var typeSymbol = source.TargetSymbol as INamedTypeSymbol;
            var typeDeclaration = source.TargetNode as TypeDeclarationSyntax;

            if (typeSymbol is null || typeDeclaration is null)
            {
                return;
            }

            // check partial, abstract, root, and packable
            if (SyntaxCheck.IsPartial(typeDeclaration) == false)
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(DiagnosticConstants.MustBePartial, typeDeclaration.GetLocation(), typeSymbol.Name)
                    );
                return;
            }

            if (SyntaxCheck.IsAbstract(typeDeclaration))
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(DiagnosticConstants.AbstractNotSuppoted, typeDeclaration.GetLocation(), typeSymbol.Name)
                    );
                return;
            }

            if (SyntaxCheck.IsNested(typeDeclaration))
            {
                context.ReportDiagnostic(
                    Diagnostic.Create(DiagnosticConstants.MustBeRoot, typeDeclaration.GetLocation(), typeSymbol.Name)
                    );
                return;
            }

            string namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
            string fullTypeName = typeSymbol.Name;
            string typeKindName = typeSymbol.TypeKind.ToString().ToLower();

            List<(string, IParameterSymbol)> additionalFields = new();

            var builder = new CodeBuilder();
            builder.AppendLine("// <auto-generated>");
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Buffers;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine("using ExtremeOsc;");
            builder.AppendLine("");

            using (var @namespace = builder.BeginScope($"namespace {namespaceName}"))
            {
                using (var @class = builder.BeginScope($"partial {typeKindName} {fullTypeName} : {IOscReceivableName}"))
                {
                    // find methods with OscCallbackAttribute
                    var methods = typeSymbol.FindMethods();

                    // check address duplication
                    var callbackAttributes = methods
                        .SelectMany(method => method.GetAttributes())
                        .Where(attribute => attribute.AttributeClass?.ToDisplayString() == OscCallbackAttributeName);
                    
                    var addressSet = new HashSet<string>();
                    foreach (var attribute in callbackAttributes)
                    {
                        string? address = attribute.ConstructorArguments[0].Value?.ToString();
                        if (string.IsNullOrEmpty(address))
                        {
                            continue;
                        }
                        if (addressSet.Contains(address))
                        {
                            context.ReportDiagnostic(
                                Diagnostic.Create(DiagnosticConstants.DuplicatedAddress, attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation(), address)
                                );
                            return;
                        }
                        else
                        {
                            addressSet.Add(address);
                        }
                    }
                    addressSet.Clear();

                    using (var @receiverBundle = builder.BeginScope($"public void ReceiveOscPacket (byte[] buffer, ref int offset, ulong timestamp = 1UL)"))
                    {
                        // address
                        builder.AppendLine("string address = OscReader.ReadString(buffer, ref offset);");

                        // recursive
                        using (var @ifBundle = builder.BeginScope("if (address == \"#bundle\""))
                        {
                            builder.AppendLine("ulong timestamp = OscReader.ReadTimeTagAsULong(buffer, ref offset)");

                            using (var @whileBundle = builder.BeginScope("while (offset < buffer.Length)"))
                            {
                                builder.AppendLine("int elementSize = OscReader.ReadInt32(buffer, ref offset);");
                                builder.AppendLine("ReceiveOscPacket(buffer, ref offset, timestamp);");
                            }
                            builder.AppendLine("return;");
                        }

                        builder.AppendLine("int offsetTagTypes = offset + 1;");
                        using (var @switch = builder.BeginScope("switch (address)"))
                        {
                            foreach (var method in methods)
                            {
                                var attributes = method.GetAttributes()
                                    .Where(method => method.AttributeClass?.ToDisplayString() == OscCallbackAttributeName);

                                if(attributes.Any(attribute => attribute.AttributeClass?.ToDisplayString() == OscCallbackAttributeName) == false)
                                {
                                    continue;
                                }

                                // check arguments
                                if (method.Parameters.Length < 1)
                                {
                                    context.ReportDiagnostic(
                                        Diagnostic.Create(DiagnosticConstants.NoArgument, method.Locations[0], method.Name)
                                        );
                                    continue;
                                }
                                // check first argument is string
                                if (method.Parameters[0].Type.ToDisplayString() != "string")
                                {
                                    context.ReportDiagnostic(
                                        Diagnostic.Create(DiagnosticConstants.FirstArgumentMustBeString, method.Locations[0], method.Name)
                                        );
                                    continue;
                                }

                                // check first argument is string named 'address'
                                if (method.Parameters[0].Type.ToDisplayString() != "string" || method.Parameters[0].Name != "address")
                                {
                                    context.ReportDiagnostic(
                                        Diagnostic.Create(DiagnosticConstants.FirstArgumentMustBeStringNamedAddress, method.Locations[0], method.Name)
                                        );
                                    continue;
                                }

                                foreach (var attribute in attributes)
                                {
                                    string? address = attribute.ConstructorArguments[0].Value?.ToString();
                                    if (string.IsNullOrEmpty(address))
                                    {
                                        continue;
                                    }

                                    // No Argument
                                    if (method.Parameters.Length == 1)
                                    {
                                        using (var @case = builder.BeginScope($"case \"{address}\":"))
                                        {
                                            builder.AppendLine($"{method.Name}(address);");
                                            builder.AppendLine("break;");
                                        }
                                    }
                                    // Packable
                                    else if (method.Parameters.Length == 2)
                                    {
                                        var parameterType = method.Parameters[1].Type;

                                        // :(
                                        if (SyntaxCheck.IsPackable(parameterType) == false &&
                                            SyntaxCheck.IsPrimitiveOnly(method) == false &&
                                            SyntaxCheck.IsObjectArrayOnly(method) == false &&
                                            SyntaxCheck.IsReaderOnly(method) == false) 
                                        {
                                            context.ReportDiagnostic(
                                                Diagnostic.Create(DiagnosticConstants.NotSupportedType, method.Locations[0], parameterType?.ToDisplayString())
                                                );
                                            continue;
                                        }

                                        if (SyntaxCheck.IsObjectArrayOnly(method))
                                        {
                                            using (var @case = builder.BeginScope($"case \"{address}\":"))
                                            {
                                                builder.AppendLine("var __reader = ExtremeOsc.OscReader.Read(buffer);");
                                                builder.AppendLine("var __objects = __reader.GetAsObjects();");
                                                builder.AppendLine($"{method.Name}(address, __objects);");
                                                builder.AppendLine("__reader.Dispose();");
                                                builder.AppendLine("break;");
                                            }
                                            // skip argument analysis
                                            continue;
                                        }
                                        else if (SyntaxCheck.IsReaderOnly(method))
                                        {
                                            using (var @case = builder.BeginScope($"case \"{address}\":"))
                                            {
                                                builder.AppendLine("var __reader = ExtremeOsc.OscReader.Read(buffer);");
                                                builder.AppendLine($"{method.Name}(address, __reader);");
                                                builder.AppendLine("__reader.Dispose();");
                                                builder.AppendLine("break;");
                                            }
                                            continue;
                                        }
                                        // Packable Type
                                        else if (SyntaxCheck.IsPrimitiveOnly(method) == false)
                                        {
                                            string parameterTypeName = parameterType.ToDisplayString();
                                            using (var @case = builder.BeginScope($"case \"{address}\":"))
                                            {
                                                var parameter = method.Parameters[1];
                                                bool isRefOrIn = parameter.RefKind == RefKind.Ref || parameter.RefKind == RefKind.In;

                                                if (isRefOrIn)
                                                {
                                                    string refKeyword = parameter.RefKind == RefKind.Ref ? "ref" : "in";
                                                    string variableName = $"__{PackableEmitter.AddressToVariableName(address)}_{parameter.Name}";
                                                    additionalFields.Add((variableName, parameter));

                                                    builder.AppendLine($"{variableName}.Unpack(buffer, ref offset);");
                                                    builder.AppendLine($"{method.Name}(address, {refKeyword} {variableName});");
                                                }
                                                else
                                                {
                                                    builder.AppendLine($"var __value = new {parameterTypeName}();");
                                                    builder.AppendLine($"__value.Unpack(buffer, ref offset);");
                                                    builder.AppendLine($"{method.Name}(address, __value);");
                                                }
                                                builder.AppendLine("break;");
                                            }
                                            // skip argument analysis
                                            continue;
                                        }
                                        
                                    }
                                    
                                    // Arguments 
                                    if (method.Parameters.Length >= 2)
                                    {
                                        if(SyntaxCheck.IsPrimitiveOnly(method) == false)
                                        {
                                            context.ReportDiagnostic(
                                                Diagnostic.Create(DiagnosticConstants.ArgumentNotPrimitive, method.Locations[0], method.Name)
                                                );
                                            continue;
                                        }

                                        var parameters = method.Parameters
                                            .Skip(1) // ignore string address
                                            .Select((p, index) =>
                                            {
                                                ITypeSymbol t = p.Type;
                                                ISymbol s = p;
                                                return (t, s, index);
                                            });

                                        using (var @case = builder.BeginScope($"case \"{address}\":"))
                                        {
                                            // read tagtypes
                                            builder.AppendLine("OscReader.ReadString(buffer, ref offset);");
                                            foreach (var parameter in parameters)
                                            {
                                                var (ts, s, i) = parameter;
                                                ReadWithDeclaration(builder, parameter, "offset", "offsetTagTypes");
                                            }

                                            string arguments = string.Join(", ", parameters.Select(p => p.s.Name));
                                            builder.AppendLine($"{method.Name}(address, {string.Join(", ", arguments)});");
                                            builder.AppendLine("break;");
                                        }
                                    }
                                }
                            }
                        }
                    }

                    using (var @receiver = builder.BeginScope($"public void ReceiveOscPacket (byte[] buffer)"))
                    {
                        builder.AppendLine("int offset = 0;");
                        builder.AppendLine("ReceiveOscPacket(buffer, ref offset);");
                    }

                    foreach (var (name, parameter) in additionalFields)
                    {
                        builder.AppendLine($"private {parameter.Type.ToDisplayString()} {name} = new {parameter.Type.ToDisplayString()}();");
                    }
                }
            }

            Console.WriteLine(builder.ToString());
            
            context.AddSource($"{fullTypeName}.OscCallback.g.cs", SourceText.From(builder.ToString(), Encoding.UTF8));
        }
    }
}
